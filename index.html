<!doctype html>
<head>
<meta charset="UTF-8">
<meta name="referrer" content="never">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>ArchiveBot dashboard 2.0</title>
</head>
<body>
<style>
html, body {
	background-color: #FFF7E1;
}

.log-window {
	overflow: hidden;
	height: 200px;
	width: 100%;
	border: 1px solid #CCC;
	margin: 0 0 1em 0;
}
</style>
<div id="traffic"></div>
<div id="logs"></div>
<script>

var assert = function(condition, message) {
	if(!condition) {
		throw message || "Assertion failed";
	}
}

var byId = function(id) {
	return document.getElementById(id);
}

var text = function(s) {
	return document.createTextNode(s);
}

/**
 * Create DOM element with attributes and children
 */
var h = function(elem, attrs, children) {
	var e = document.createElement(elem);
	if(attrs != null) {
		for(attr in attrs) {
			e[attr] = attrs[attr];
		}
	}
	if(children != null) {
		for(var i=0; i < children.length; i++) {
			console.log(children[i]);
			e.appendChild(children[i]);
		}
	}
	return e;
}

var href = function(href, text) {
	var a = h("a");
	a.href = href;
	a.textContent = text;
	return a;
}

var prettyJson = function(obj) {
	return JSON.stringify(obj, undefined, 2);
}

// Copied from Coreweb/js_coreweb/cw/string.js
/**
 * Like Python's s.split(delim, num) and s.split(delim)
 * This does *NOT* implement Python's no-argument s.split()
 *
 * @param {string} s The string to split.
 * @param {string} sep The separator to split by.
 * @param {number} maxsplit Maximum number of times to split.
 *
 * @return {!Array.<string>} The splitted string, as an array.
 */
var split = function(s, sep, maxsplit) {
	assert(typeof sep == "string",
		"arguments[1] of split must be a separator string");
	if(maxsplit === undefined || maxsplit < 0) {
		return s.split(sep);
	}
	var pieces = s.split(sep);
	var head = pieces.splice(0, maxsplit);
	// after the splice, pieces is shorter and no longer has the `head` elements.
	if(pieces.length > 0) {
		var tail = pieces.join(sep);
		head.push(tail); // no longer just the head.
	}
	return head;
};

/**
 * [[1, 2], [3, 4]] -> {1: 2, 3: 4}
 */
var intoObject = function(arr) {
	var obj = {};
	arr.forEach(function(e) {
		obj[e[0]] = e[1];
	});
	return obj;
};

var getQueryArgs = function() {
	var pairs = location.search.replace("?", "").split("&");
	if(pairs == "") {
		return {};
	}
	return intoObject(pairs.map(function(e) { return split(e, "=", 1); }));
};

/*** End of utility code ***/



var Jobs = function() {
	this.known = {};
	this.sorted = [];
};

Jobs.prototype.resort = function() {
	this.sorted.sort(function(a, b) { return a["started_at"] > b["started_at"] ? -1 : 1 });
}

/**
 * Returns true if a new job was added
 */
Jobs.prototype.handleJobData = function(data) {
	var ident = data["ident"];
	var url = data["url"];
	var started_at = data["started_at"];
	var alreadyKnown = ident in this.known;
	if(!alreadyKnown) {
		this.known[ident] = true;
		this.sorted.push(data);
		this.resort();
	}
	return !alreadyKnown;
};


var JobsRenderer = function(container) {
	this.jobs = new Jobs();
	this.container = container;
};

JobsRenderer.prototype._getNextJobInSorted = function(ident) {
	for(var i=0; i < this.jobs.sorted.length; i++) {
		var e = this.jobs.sorted[i];
		if(e["ident"] == ident) {
			return this.jobs.sorted[i+1];
		}
	}
	return null;
};

JobsRenderer.prototype.handleJobData = function(data) {
	var added = this.jobs.handleJobData(data);
	if(added) {
		var beforeJob = this._getNextJobInSorted(data["ident"]);
		var beforeElement = beforeJob == null ? null : byId("log-container-" + beforeJob["ident"]);

		var div = h(
			'div',
			{"id": "log-container-" + data["ident"]}, [
				href(data["url"], data["url"]),
				text(" " + data["ident"]),
				h(
					'div', {
						"className": "log-window",
						"id": "log-window-" + data["ident"]
					}
				)
			]
		);
		this.container.insertBefore(div, beforeElement);
	}
};


var Dashboard = function() {
	this.ws = null;
	this.jobsRenderer = new JobsRenderer(byId('logs'));
	this.messageCount = 0;
}

Dashboard.prototype.setup = function() {
	var args = getQueryArgs();
	var dumpTraffic = args.dumpMax && Number(args.dumpMax) > 0;
	if(dumpTraffic) {
		var dumpMax = Number(args.dumpMax);
	}
	this.ws = new WebSocket("ws://arshboard.at.ninjawedding.org:4567/stream");
	// TODO: batch incoming messages, handle them every 100ms or so
	// If we batch here, we probably don't even need to batch DOM updates
	this.ws.onmessage = function(ev) {
		var data = JSON.parse(ev["data"]);
		this.messageCount += 1;
		if(dumpTraffic && this.messageCount <= dumpMax) {
			byId('traffic').appendChild(h("pre", null, [text(prettyJson(data))]));
		}
		this.jobsRenderer.handleJobData(data["job_data"]);
	}.bind(this);
}

var ds = new Dashboard();
ds.setup();

</script>
</body>
</html>
