<!doctype html>
<head>
<meta charset="UTF-8">
<meta name="referrer" content="never">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>ArchiveBot dashboard 2.0</title>
</head>
<body>
<style>
html, body {
	background-color: #F4E2AA;
	font-family: Tahoma, Arial, sans-serif;
	font-size: 13px;
}

.header {
	font-family: Arial, sans-serif;
	font-weight: bold;
	font-size: 18px;
}

.job-url {
	font-weight: bold;
	text-decoration: none;
}

.log-window {
	background-color: #FFF7E1;
	overflow-y: scroll;
	height: 200px;
	width: 100%;
	border: 1px solid #CCC;
	margin: 0 0 1em 0;
}

.line {
	white-space: nowrap;
}

.line a {
	text-decoration: none;
}
</style>
<span class="header">
	<a href="http://archiveteam.org/index.php?title=ArchiveBot">ArchiveBot</a>
	tracking ~<span id="num-crawls">0</span> crawls.<br>
</span><br>


<div id="traffic"></div>
<div id="logs"></div>
<script>

var assert = function(condition, message) {
	if(!condition) {
		throw message || "Assertion failed";
	}
};

var byId = function(id) {
	return document.getElementById(id);
};

var text = function(s) {
	return document.createTextNode(s);
};

/**
 * appendChild but accepts strings and arrays of children|strings
 */
var appendAny = function(e, thing) {
	if(Array.isArray(thing)) {
		for(var i=0; i < thing.length; i++) {
			appendAny(e, thing[i]);
		}
	} else if(typeof thing == "string") {
		e.appendChild(text(thing));
	} else {
		// TODO: Check that it's actually a DOM node first
		e.appendChild(thing);
	}
};

/**
 * Create DOM element with attributes and children from Array<node|string>|node|string
 */
var h = function(elem, attrs, thing) {
	var e = document.createElement(elem);
	if(attrs != null) {
		for(attr in attrs) {
			e[attr] = attrs[attr];
		}
	}
	if(thing != null) {
		appendAny(e, thing);
	}
	return e;
};

var href = function(href, text) {
	var a = h("a");
	a.href = href;
	a.textContent = text;
	return a;
};

var prettyJson = function(obj) {
	return JSON.stringify(obj, undefined, 2);
};

// Copied from Coreweb/js_coreweb/cw/string.js
/**
 * Like Python's s.split(delim, num) and s.split(delim)
 * This does *NOT* implement Python's no-argument s.split()
 *
 * @param {string} s The string to split.
 * @param {string} sep The separator to split by.
 * @param {number} maxsplit Maximum number of times to split.
 *
 * @return {!Array.<string>} The splitted string, as an array.
 */
var split = function(s, sep, maxsplit) {
	assert(typeof sep == "string",
		"arguments[1] of split must be a separator string");
	if(maxsplit === undefined || maxsplit < 0) {
		return s.split(sep);
	}
	var pieces = s.split(sep);
	var head = pieces.splice(0, maxsplit);
	// after the splice, pieces is shorter and no longer has the `head` elements.
	if(pieces.length > 0) {
		var tail = pieces.join(sep);
		head.push(tail); // no longer just the head.
	}
	return head;
};

/**
 * [[1, 2], [3, 4]] -> {1: 2, 3: 4}
 */
var intoObject = function(arr) {
	var obj = {};
	arr.forEach(function(e) {
		obj[e[0]] = e[1];
	});
	return obj;
};

var getQueryArgs = function() {
	var pairs = location.search.replace("?", "").split("&");
	if(pairs == "") {
		return {};
	}
	return intoObject(pairs.map(function(e) { return split(e, "=", 1); }));
};

/*** End of utility code ***/



var JobsTracker = function() {
	this.known = {};
	this.sorted = [];
};

JobsTracker.prototype.resort = function() {
	this.sorted.sort(function(a, b) { return a["started_at"] > b["started_at"] ? -1 : 1 });
}

/**
 * Returns true if a new job was added
 */
JobsTracker.prototype.handleJobData = function(jobData) {
	var ident = jobData["ident"];
	var alreadyKnown = ident in this.known;
	if(!alreadyKnown) {
		this.known[ident] = true;
		this.sorted.push(jobData);
		this.resort();
	}
	return !alreadyKnown;
};


var JobsRenderer = function(container) {
	this.jobs = new JobsTracker();
	this.container = container;
	this._classNameLine = {"className": "line"};
};

JobsRenderer.prototype._getNextJobInSorted = function(ident) {
	for(var i=0; i < this.jobs.sorted.length; i++) {
		var e = this.jobs.sorted[i];
		if(e["ident"] == ident) {
			return this.jobs.sorted[i+1];
		}
	}
	return null;
};

JobsRenderer.prototype._createLogContainer = function(jobData) {
	var beforeJob = this._getNextJobInSorted(jobData["ident"]);
	var beforeElement = beforeJob == null ? null : byId("log-container-" + beforeJob["ident"]);

	var div = h(
		'div',
		{"id": "log-container-" + jobData["ident"]}, [
			h("a", {"className": "job-url", "href": jobData["url"]}, jobData["url"]),
			text(" " + jobData["ident"]),
			h(
				'div', {
					"className": "log-window",
					"id": "log-window-" + jobData["ident"]
				}
			)
		]
	);
	this.container.insertBefore(div, beforeElement);
}

JobsRenderer.prototype._renderDownloadLine = function(data, logWindow) {
	// TODO: Use cached object for the text(response code + wget code)
	logWindow.appendChild(h("span", this._classNameLine, [
		text(data["response_code"] + " " + data["wget_code"] + " "),
		href(data["url"], data["url"])
	]));
	logWindow.appendChild(h("br"));
	logWindow.scrollTop = logWindow.scrollHeight;
};

JobsRenderer.prototype._renderStdoutLine = function(data, logWindow) {
	logWindow.appendChild(h("span", this._classNameLine, data["message"]));
	logWindow.appendChild(h("br"));
	logWindow.scrollTop = logWindow.scrollHeight;
};

JobsRenderer.prototype.handleData = function(data) {
	var added = this.jobs.handleJobData(data["job_data"]);
	if(added) {
		this._createLogContainer(data["job_data"]);
		byId('num-crawls').textContent = this.jobs.sorted.length;
	}
	var type = data["type"];
	if(!(type == "download" || type == "stdout")) {
		return;
	}

	var logWindow = byId("log-window-" + data["job_data"]["ident"]);
	if(!logWindow) {
		console.warn("Element with id log-window-" + data["job_data"]["ident"] + " does not exist.");
		return;
	}

	if(type == "download") {
		this._renderDownloadLine(data, logWindow);
	} else if(type == "stdout") {
		this._renderStdoutLine(data, logWindow);
	}
};


var Dashboard = function() {
	this.ws = null;
	this.jobsRenderer = new JobsRenderer(byId('logs'));
	this.messageCount = 0;
};

Dashboard.prototype.setup = function() {
	var args = getQueryArgs();
	var dumpTraffic = args["dumpMax"] && Number(args["dumpMax"]) > 0;
	if(dumpTraffic) {
		var dumpMax = Number(args["dumpMax"]);
	}
	this.ws = new WebSocket("ws://arshboard.at.ninjawedding.org:4567/stream");
	// TODO: batch incoming messages, handle them every 100ms or so
	// If we batch here, we probably don't even need to batch DOM updates
	this.ws.onmessage = function(ev) {
		var data = JSON.parse(ev["data"]);
		this.messageCount += 1;
		if(dumpTraffic && this.messageCount <= dumpMax) {
			byId('traffic').appendChild(h("pre", null, prettyJson(data)));
		}
		this.jobsRenderer.handleData(data);
	}.bind(this);
}

var ds = new Dashboard();
ds.setup();

</script>
</body>
</html>
